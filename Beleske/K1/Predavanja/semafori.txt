- Problem kriticne sekcije
sem mutex = 1;
process CS[i = 1 to n] {
	while (true) {
		wait(mutex);
		critical section;
		signal(mutex);
		noncritical section;
	}
}

- Producers and consumers (n) - raspodeljeni binarni semafori
	* dobro resenje u slucaju kada se nesto retko proizvodi, a cim se proizvede se potrosi - nema mnogo
	semafora, jednostavna sinhronizacija
	* nije dobro resenje u slucaju da se to sto se proizvodi ne potrosi odmah - ima onda mnogo cekanja
	da se proizvod potrosi pre pravljenja novog - resenje za to je onda Bounded buffer jer u njega
	mogu proizvodi da se taloze iako se ne trose odmah - bolja konkurentnost programa
typeT buf;
sem empty = 1, full = 0;
process Producer[i = 1 to M] {
	while (true) {
		/* proizvedi podatak i unesi */
		wait(empty);
		buf = data;
		signal(full);
		...
	}
}
process Consumer[j = 1 to N] {
	while (true) {
		/* uzmi rezultat */
		wait(full);
		result = buf;
		signal(empty);
		...
	}
}

- Bounded buffer - po jedan proizvodjac i potrosac
	* povecana konkurentnost uz pomoc bafera i inicijalizovanja semafora empty = n jer je tako
	omoguceno da proizvodjac proizvodi dalje i stavlja u bafer iako prethodni proizvodi nisu potroseni
	od strane potrosaca
typeT buf[n];
int front = 0, rear = 0;
sem empty = n, full = 0;
process Producer {
	while (true) {
		/* proizvedi podatak */
		wait(empty);
		buf[rear] = data; rear = (rear + 1) % n;
		signal(full);
		...
	}
}
process Consumer {
	while (true) {
		/* dohvati rezultat */
		wait(full);
		result = buf[front]; front = (front + 1) % n;
		signal(empty);
		...
	}
}

- Bounded buffer - M proizvodjaca i N potrosaca
	* posto sad ima vise proizvodjaca i potrosaca, a dodele rear = (rear + 1) % n i front = (front + 1) % n
	nisu atomicne, potrebno je obezbediti medjusobno iskljucenje pomocu mutex-a, pri cemu treba
	koristiti jedan mutex za proizvodjace i jedan za potrosace jer ne smemo samo da dozvolimo da dva
	proizvodjaca istovremeno upisuju u bafer ili da dva potrosaca istovremeno uzimaju iz bafera - u redu 
	je ako proizvodjac stavlja u bafer istovremeno dok potrosac uzima iz bafera jer menjaju razlicite
	promenljive (rear i front) i jer smo sigurni da ne moze da se dogodi da proizvodjac upisuje 
	u neku lokaciju u baferu istovremeno dok potrosac uzima iz te iste lokacije - to je obezbedjeno
	uslovnom sinhronizacijom pomocu semafora empty i full
typeT buf[n];
int front = 0, rear = 0;
sem empty = n, full = 0;
sem mutexP = 1, mutexC = 1;
process Producer {
	while (true) {
		/* proizvedi podatke */
		wait(empty);
		wait(mutexP);
		buf[rear] = data; rear = (rear + 1) % n;
		signal(mutexP);
		signal(full);
		...
	}
}
process Consumer {
	while (true) {
		/* dohvati rezultat */
		wait(full);
		wait(mutexC);
		result = buf[front]; front = (front + 1) % n;
		signal(mutexC);
		signal(empty);
		...
	}
}

- Dining philosophers
process Philosopher[i = 0 to 4] {
	while (true) {
		razmisljaj;
		dohvati viljuske;
		jedi;
		oslobodi viljuske;
	}
}

- Mrtvo blokiranje (Deadlock)
	* nastaje ako su zadovoljena sledeca 4 uslova:
		1) Procesi imaju pravo ekskluzivnog pristupa resursima (Mutual exclusion)
		2) Proces drzi resurs sve vreme dok ceka pristup drugom resursu (Wait and Hold)
		3) Proces ne moze preuzeti resurs na koji ceka (No preemption)
		4) Postoji zatvoren krug procesa koji cekaju jedan drugog - jedan proces ceka na ispunjenje
		uslova koji obezbedjuje drugi proces, drugi proces ceka na ispunjenje uslova koji obezbedjuje
		treci proces itd., a poslednji proces u tom nizu ceka na ispunjenje uslova koji obezbedjuje prvi
		proces (Circular wait)
	* dovoljno je otkloniti jedan od ova 4 uslova da bi se sprecio deadlock
	
- Dining philosophers
	* resenje u kome moze da dodje do deadlock-a
	* najgori slucaj u kome se svi filozofi ispreplicu:
		- npr. svaki filozof uzme levu viljusku i pre nego sto pokusa da uzme desnu, naredni susedni
		filozof ga pretekne tako sto i on uzme svoju levu viljusku i tako se onda svi blokiraju i niko ne
		moze da jede
sem fork[5] = {1, 1, 1, 1, 1};
process Philosopher[i = 0 to 4] {
	while (true) {
		/* leva pa desna viljuska */
		wait(fork[i]);
		wait(fork[(i+1) % n]);
		eat;
		signal(fork[i]);
		signal(fork[(i+1) % n]);
		think;
	}
}
	
- Dining philosophers
	* resen problem mrtve blokade tako sto ce prva 4 filozofa traziti prvo levu pa desnu viljusku, dok
	ce peti filozof da trazi prvo desnu pa levu viljusku - otklonjena kruzna zavisnost izmedju resursa
	* najgori slucaj ako se svi filozofi ispreplicu:
		- prva 4 filozofa uzmu leve viljuske, filozofi (i = 0, 1, 2) ce se blokirati, filozof (i = 4) ce se
		takodje blokirati, ali zato sto ce prvo probati da uzme svoju desnu viljusku, a to je vec leva 
		viljuska filozofa (i = 0) koju je on uzeo, tako da ce onda ostati neblokiran filozof (i = 3) i moci 
		ce da jede jer ce mu biti slobodna desna viljuska, a levu je vec uzeo
sem fork[5] = {1, 1, 1, 1, 1};
process Philosopher[i = 0 to 3] {
	while (true) {
		/* leva pa desna viljuska */
		wait(fork[i]);
		wait(fork[i+1]);
		eat;
		signal(fork[i]);
		signal(fork[i+1]);
		think;
	}
}
process Philosopher[4] {
	while (true) {
		/* desna pa leva viljuska */
		wait(fork[0]);
		wait(fork[4]);
		eat;
		signal(fork[0]);
		signal(fork[4]);
		think;
	}
}

- Dining philosophers
	* i u ovom resenju nema mrtve blokade (deadlock-a), pri cemu je program konkurentniji nego prosli
	* filozofi (i = 0) i (i = 1) se prvo takmice za viljusku (fork[1]), a filozofi (i = 2) i (i = 3) se prvo 
	takmice za viljusku (fork[3])
		- zbog ovoga je u ovom resenju veca konkurentnost programa, a obrazlozenje je sledece:
		filozofi (i = 0) i (i = 1), kao i filozofi (i = 2) i (i = 3) su medjusobno susedi, i oni svakako ne mogu
		nikada istovremeno da jedu, pa je najbolje da se oni prvo medjusobno takmice za viljuske koje
		su izmedju njih jer ce se onda onaj sused koji izgubi u tom takmicenju blokirati i pritom nece
		bezveze drzati kod sebe nijednu viljusku, sto je odlicno jer se tako smanjuje pojava drzanja 
		resursa dok se ceka drugi resurs (Hold and Wait), i upravo to povecava konkurentnost programa,
		dakle u ovom resenju su mnogo vece sanse da dva filozofa jedu istovremeno nego u proslom
	* pogledati graf resursa na slajdu 97 (prezentacija Konkurentno programiranje.pdf)
	* kada se pogleda graf resursa, sto su kraci putevi koji se mogu pratiti pomocu strelica izmedju
	resursa, to je program konkurentniji (logicno, jer je bolje da se sto manje mogu ulancati situacije
	Hold and Wait-a)
		- npr. u ovom resenju, najduzi put koji se moze ispratiti je duzine jednog resursa, a u proslom
		resenju je duzine cak 5 resursa
sem fork[5] = {1, 1, 1, 1, 1};
process Philosopher[i = 0, 2, 4] {
	while (true) {
		/* desna pa leva viljuska */
		wait(fork[(i+1) % n]);
		wait(fork[i]);
		eat;
		signal(fork[(i+1) % n]);
		signal(fork[i]);
		think;
	}
}
process Philosopher[i = 1, 3] {
	while (true) {
		/* leva pa desna viljuska */
		wait(fork[i]);
		wait(fork[(i+1) % n]);
		eat;
		signal(fork[i]);
		signal(fork[(i+1) % n]);
		think;
	}
}

- Graph-Based Protocols
	* Neka je R skup svih resursa i neka su ri i rj dva resursa iz datog skupa. Ukoliko se u dati skup
	uvede relacija parcijalnog uredjenja (-->) kod koje je resurs ri pre resursa rj (ri-->rj) onda i svaki
	proces koji pristupa resursima ri i rj mora da im pristupi tako sto ce prvo da pristupi resursu ri, pa
	onda resursu rj
	* Graf resursa formiran na ovaj nacin je usmereni aciklicni graf - garantovano nema deadlock-a
	* Graf resursa bi trebalo formirati na takav nacin da vodi racuna o tome koji proces pristupa kojim
	resursima
	
- Readers/Writers problem (jednostavan kritican region)
	* ovo resenje radi, ali ima problem manjka konkurentnosti - nije moguce da vise citalaca istovremeno
	pristupaju resursu
	* treba da bude onemoguceno da se u resurs u isto vreme upisuje i da se on cita, ali ako se ne radi
	upis u resurs, treba da se omoguci da moze vise citalaca da ga cita istovremeno
sem rw = 1;
process Reader[i = 1 to m] {
	while (true) {
		...
		wait(rw);
		read database;
		signal(rw);
		...
	}
}
process Writer[i = 1 to n] {
	while (true) {
		...
		wait(rw);
		write database;
		signal(rw);
		...
	}
}

- Readers/Writers problem (resenje 1) - coarse-grain
	* samo prvi citalac se sinhronizuje sa piscima, ostali prolaze - omoguceno da vise citalaca cita
	resurs istovremeno, tako da je poboljsana konkurentnost
	* mana ovog resenja:
		- moze doci do izgladnjivanja pisaca, jer kada prvi citalac zapocne citanje, citaoci imaju prednost
		i moze neogranicen broj citalaca da cita resurs neograniceno dugo - dakle prednost imaju citaoci,
		nije fer resenje
int nr = 0; sem rw = 1;
process Reader[i = 1 to m] {
	while (true) {
		...
		<nr = nr + 1; if (nr == 1) wait(rw);>
		read database;
		<nr = nr - 1; if (nr == 0) signal(rw);>
	}
}
process Writer[j = 1 to n] {
	while (true) {
		wait(rw);
		write database;
		signal(rw);
	}
}

- Readers/Writers problem (resenje 1) - fine-grain
int nr = 0; 
sem rw = 1; /* semafor rw cuva database */
sem mutexR = 1;  /* mutexR cuva promenljivu nr */
process Reader[i = 1 to m] {
	while (true) {
		...
		wait(mutexR);
		nr = nr + 1;
		if (nr == 1) wait(rw);
		signal(mutexR);  /* bitno da ovaj signal bude posle ovog if-a iznad da ne bi moglo da se dogodi da ako se npr. blokira prvi citalac jer pisac trenutno pise, naredni citaoci prodju u kriticnu sekciju - to bi se desilo da je ovaj signal iznad if-a */
		read database;
		wait(mutexR);
		nr = nr - 1;
		if (nr == 0) signal(rw);
		signal(mutexR);
		...
	}
}
process Writer[j = 1 to n] {
	while (true) {
		wait(rw);
		write database;
		signal(rw);
	}
}

- Readers/Writers problem (resenje 1 sa ogranicavanjem dolazaka) - fine-grain
	* resen problem izgladnjivanja pisaca pomocu semafora enter (uz pretpostavku da je ovo fer
	semafor koji postuje FIFO redosled pustanja procesa) koji obezbedjuje da se ne zanemaruju
	novi pisci koji dolaze kada ima vise citalaca koji citaju resurs istovremeno - dalje ce se pustati 
	procesi FIFO redosledom nezavisno od toga da li je u pitanju citalac ili pisac
		* ovo resenje ne radi ukoliko semafor enter ne postuje FIFO redosled vec nasumicno budi
		blokirane procese
int nr = 0; 
sem rw = 1;  /* semafor rw cuva database */
sem mutexR = 1;  /* mutexR cuva promenljivu nr */
sem enter = 1; /* semafor enter ogranicava nove citaoce/pisce da udju, ali ne i stare da odu iz kriticne sekcije */
process Reader[i = 1 to m] {
	while (true) {
		...
		wait(enter);
		wait(mutexR);
		nr = nr + 1;
		if (nr == 1) wait(rw);
		signal(mutexR);  
		signal(enter);
		read database;
		wait(mutexR);
		nr = nr - 1;
		if (nr == 0) signal(rw);
		signal(mutexR);
		...
	}
}
process Writer[j = 1 to n] {
	while (true) {
		wait(enter);
		wait(rw);
		signal(enter);
		write database;
		signal(rw);
	}
}

- Prosledjivanje stafete
	* opsta tehnika za implementaciju await iskaza uz pomoc semafora
	* raspodeljeni semafori - najvise jedan moze da ima vrednost 1 u svakom trenutku, wait je uvek
	pracen sa signal
	* jedan semafor (e) se koristi za ulazak u svaki atomski iskaz (<)
	* svaki await(B) uslov je zamenjen semaforom i informacijom o blokiranom procesu (brojacem, 
	listom, ...)
	* SIGNAL - kod koji definise za koji semafor je signal (>)
	
	<await(B); S;>
	<=>
	wait(e);
	if (not B) DELAY;
	S;
	SIGNAL;
	
	<S;>
	wait(e);
	S;
	SIGNAL;

- DELAY kod (moguc izgled)
	* za svaki delay condition (uslov za zakasnjavanje, u primeru je to uslov B) postoji poseban semafor
	* pored ovoga potrebno je da postoji informacija o zakasnjenjima (brojac zakasnjenih ili lista, ...)
if (not B) {
	dp = dp + 1;  /* tekuci proces belezi u ovom brojacu da je on zablokiran na ovom uslovu (B) */
	signal(e);  /* omogucavamo npr. da neki novi proces dodje i pokusa da prodje uslov B */
	wait(rs);  /* rs je semafor koji je napravljen specificno za uslov B */
}

- SIGNAL kod (moguc izgled)
	* bitan je redosled ispitivanja uslova i zavisi od toga koji uslovi su prioritetniji (oni ce se ranije
	ispitati)
	* ovaj kod uvek pusta tacno jedan proces da nastavi dalje
if (B') {  /* uslov B' pod kojim se proces deblokira sa semafora rs NE MORA da bude jednak uslovu B zbog kog se isti taj proces blokirao na semaforu rs */
	dp = dp - 1;  /* azuriranje informacije u broju zablokiranih procesa na semaforu rs */
	signal(rs);  /* deblokiranje jednog procesa sa semafora rs */
} else if (B1') {
	dp1 = dp1 - 1;
	signal(rs1);
} ...
else signal(e);  /* ako nijedan uslov nije zadovoljen, omogucavamo novom procesu da udje u atomski iskaz */

- Readers/Writers - bez izgladnjivanja pisaca (coarse-grain)
List l;
int nr = 0, nw = 0;
process Reader[i = 1 to m] {
	while (true) {
		...
		<await(nw == 0 && l.size() == 0); nr = nr + 1;>
		read database;
		<nr = nr - 1;>
		...
	}
}
process Writer[j = 1 to n] {
	while (true) {
		...
		<await(nr == 0 && nw == 0 && l.size() == 0); nw = nw + 1;>
		write database;
		<nw = nw - 1;>
		...
	}
}

- Readers/Writers - pomocu prosledjivanja stafete i raspodeljenih binarnih semafora
	* dozvola za ulazak u kriticnu sekciju se dobija preko bilo kog semafora koji sacinjava raspodeljeni
	binarni semafor, a stafeta se predaje dalje pomocu SIGNAL koda
	* ovo je univerzalna tehnika koja moze da se primeni na svaki sinhronizacioni problem
	* tehnika prosledjivanja stafete je dosta brza jer jedan proces maksimalno ceka na 2 semafora (
	citaoci na semaforima e i r, a pisci na semaforima e i w)
	* u listi l se cuvaju u FIFO redosledu samo informacije o tome u kom redosledu su bili blokirani
	citaoci i pisci (ona izgleda npr. ovako ["R", "R", "W", "R", "W"]) - to znaci da cemo u kodu za SIGNAL
	u "pravednom" redosledu buditi tipove procesa, medjutim nemamo pojma kog tacno citaoca ili pisca
	cemo probuditi posto nije garantovano da su semafori r i w na kojima se blokiraju citaoci i pisci
	posteni (tj. da obezbedjuju FIFO redosled) - ovaj problem resavaju privatni semafori jer kod njih
	svaki proces ceka na svom privatnom semaforu, pa je onda garantovano da ce on biti probudjen cak
	iako je taj privatni semafor neposten
	
List l;  /* u ovoj listi se cuvaju informacije o blokiranim citaocima i piscima u FIFO redosledu */
sem e = 1;
sem r = 0;  /* ova tri semafora stite promenljive l, nr i nw */
sem w = 0;  /* semafori e, r i w zapravo predstavljaju jedan raspodeljeni binarni semafor jer uvek od ova 3 maksimalno jedan semafor moze imati vrednost 1 u datom trenutku */
int nr = 0, nw = 0;
process Reader[i = 1 to m] {
	while (true) {
		...
		wait(e);
		if (nw > 0 || l.size() > 0) {
			l.put("R");
			signal(e);
			wait(r);
		}
		nr = nr + 1;
		SIGNAL
		read database;
		wait(e);
		nr = nr - 1;
		SIGNAL
		...
	}
}
process Writer[j = 1 to n] {
	while (true) {
		...
		wait(e);
		if (nw > 0 || nr > 0 || l.size() > 0) {
			l.put("W");
			signal(e);
			wait(w);
		}
		nw = nw + 1;
		SIGNAL
		write database;
		wait(e);
		nw = nw - 1;
		SIGNAL
		...
	}
}
SIGNAL
	if (l.size() > 0 && l.get(0) == "R" && nw == 0) {
		l.remove(0);
		signal(r);
	} else if (l.size() > 0 && l.get(0) == "W" && nr == 0 && nw == 0) {
		l.remove(0);
		signal(w);
	} else signal(e);
	
- Shortest Job Next Allocation (SJN)
	* ovaj problem resavamo pomocu privatnih semafora (svakom procesu se dodeljuje po jedan semafor
		na kom ce on cekati, pa zahvaljujuci tome mozemo da budimo tacno odredjen proces koji zelimo)
	* proces koji je deklarisao da ce najkrace koristiti neki deljeni resurs ce ga prvi dobiti kada se 
	taj resurs oslobodi
	* ako su dva razlicita procesa najavila da ce koristiti deljeni resurs isto vreme, prednost ce imati
	onaj sto se prvi najavio (FIFO redosled)
	
- Shortest Job Next Allocation (SJN) - coarse-grain
bool free = true;
request(time, id): <await(free); free = false;>
release(): <free = true;>

- Shortest Job Next Allocation (SJN) - fine-grain, ali bazicno
bool free = true;

request(time, id):
wait(e);
if (!free) DELAY;
free = false;
SIGNAL;

release():
wait(e);
free = true;
SIGNAL;

- Shortest Job Next Allocation (SJN) - fine-grain (sa privatnim semaforima)
	* semafor e i privatni semafori b[n] se svi zajedno ovde ponasaju kao jedan raspodeljeni binarni
	semafor jer uvek u jednom trenutku moze najvise jedan od ovih semafora da ima vrednost 1
	* obezbedjen FIFO redosled za procese sa istom vrednoscu najavljenog vremena koriscenja resursa
	time, cak iako imamo nepostene semafore (to je zato sto svaki proces jedini ceka na svom semaforu
	i garantovano je da ce se zaista on probuditi kada se pozove signal za taj semafor)
	* iako su privatni semafori cesto dobro resenje za razne probleme, ne treba preterati sa njihovim
	koriscenjem jer to onda moze biti veliko opterecenje za operativni sistem
		- tamo gde je moguce, treba teziti smanjenju broja privatnih semafora
bool free = true;
sem e = 1;
sem b[n] = ([n] 0);
typedef Pairs = ordered set of (int, int);  /* ovo je rastuce uredjeni skup parova (time, id) */
Pairs pairs = { };

request(time, id):
wait(e);
if (!free) {
	pairs.insert(time, id);
	signal(e);
	wait(b[id]);
}
free = false;
signal(e);

release():
wait(e);
free = true;
if (pairs != null) {
	id = (pairs.remove(0))[1];  /* ovako dohvatamo indeks semafora za dati proces kojeg treba odblokirati */
	signal(b[id]);  /* prosledjivanje stafete do procesa sa datim id */
} else signal(e);

- Generalizacija alokacije (uz pomoc prosledjivanja stafete i privatnih semafora)
	* u ovom problemu umesto jednog deljenog resursa postoji niz deljenih resursa koje procesi mogu
	da koriste
	* prednost imaju procesi koji najave koriscenje manjeg broja resursa (ukoliko su najavljena vremena
	koriscenja ista)
		- ovo moze dovesti do izgladnjivanja procesa koji su najavili koriscenje velikog broja resursa
			* ova pojava se moze ublaziti dinamickom promenom prioriteta - sto duze neki proces ceka,
			to ga vise prebacujemo ga pocetku liste blokiranih (Aging)

int available = m;  /* na pocetku je slobodno svih m resursa */
sem e = 1;
sem b[n] = ([n] 0);
typedef Tuple = ordered set of (int, int, int);  /* ovo je rastuce uredjeni (po atributu time) skup torki (amount, time, id) */
Tuple tuples = { };

request(amount, time, id):
wait(e);
if (amount > available) {
	tuples.insert(amount, time, id);
	signal(e);
	wait(b[id]);
}
available = available - amount;
signal(e);

release():
wait(e);
available = available + amount;
if (tuples != null) {
	tuple = tuples.get(0)[0];  /* dohvatanje prve torke bez uklanjanja iz skupa torki */
	requestedAmount = tuple[0];
	if (requestedAmount <= available) {
		tuples.remove(0);
		id = tuple[2]; /* ovako dohvatamo indeks semafora za dati proces kojeg treba odblokirati */
		signal(b[id]);  /* prosledjivanje stafete do procesa (budjenje procesa) sa datim id */
	} else {
		signal(e);
	}
} else signal(e);

- Jednokratna barijera sa semaforima (moze samo jednom da se iskoristi)
sem arrive1 = 0;
sem arrive2 = 0;
process Worker1 {
	...
	signal(arrive1);
	wait(arrive2);
	...
}
process Worker2 {
	...
	signal(arrive2);
	wait(arrive1);
	...
}

- Problemi sa semaforima
	* koriscenje semafora je najkomplikovaniji nacin sinhronizacije
	* semafori su najstariji vid sinhronizacije procesa
	* wait i signal operacije treba da budu u parovima rastrkanim po kodu
	* lako moze doci do deadlock-a usled neke greske
	* lako moze doci do izgladnjivanja procesa
	* za medjusobno iskljucivanje i uslovnu sinhronizaciju se koriste iste primitive