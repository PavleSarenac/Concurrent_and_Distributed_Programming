* napomene:
	- kriticna referenca je referenca na promenljivu koja se menja od strane drugog procesa
	- kada neki programski segment ima At-Most-Once-Property, to znaci da se taj segment izvrsava
	kao da je atomicna operacija
	- dodela x := v ima At-Most-Once-Property (javlja se kao atomicna operacija) u sledece dve situacije:
		1) kada v sadrzi najvise jednu kriticnu referencu i x se ne cita od strane drugog procesa
		2) kada v ne sadrzi nijednu kriticnu referencu i x se cita od strane drugog procesa
		
- Await iskaz
	* ako nije ispunjen At-Most-Once-Property, neophodna je coarse-grained (krupnija) atomska akcija
	* <await(B);> <==> while not (B) skip;
		- ova dva su ekvivalentna ukoliko uslov B ima At-Most-Once-Property
	* <await(B); S;>
		- B specificira delay condition (uslov kasnjenja), na kom moze da se blokira proces sve dok ne
		postane B == true
		- S je sekvenca iskaza za koje je garantovano da terminiraju
	
		
- Medjusobno iskljucivanje
	* skup susednih atomskih akcija koji treba da se izvrsi kao krupnija nedeljiva akcija se naziva
	kriticna sekcija i za njeno izvrsavanje je potrebno obezbediti medjusobno iskljucivanje
	* medjusobno iskljucivanje je neophodno obezbediti samo za deljene resurse (promenljive), posto
	logicno samo njih koristi vise razlicitih procesa
	* <S;> - bezuslovna atomska akcija
	* <await(B); S;> - uslovna atomska akcija
		
- Proizvodjac/potrosac sinhronizacija (deljeni jednoelementni bafer za kopiranje niza)
int buf, p = 0, c = 0;  /* deljene promenljive */
process Producer {
	int a[n];
	while (p < n) {
		<await(p == c);>  /* sinhronizacija na empty */
		buf = a[p];
		p = p + 1;
	}
}
process Consumer {
	int b[n];
	while (c < n) {
		<await(p > c);>  /* sinhronizacija na full */
		b[c] = buf;
		c = c + 1;
	}
}

- Kriticna sekcija za dva procesa
bool in1 = false, in2 = false;
process CS1 {
	while (true) {
		<await(!in2) in1 = true;>  /* entry */
		critical section;
		in1 = false;  /* exit */
		noncritical section;
	}
}
process CS2 {
	while (true) {
		<await(!in1) in2 = true;>  /* entry */
		critical section;
		in2 = false;  /* exit */
		noncritical section;
	}
}

- Kriticna sekcija za vise procesa
bool lock = false;
process CSi {
	while (true) {
		<await(!lock) lock = true;>  /* entry */
		critical section;
		lock = false;  /* exit */
		noncritical section;
	}
}

- Test and Set (TS)
	* posebna instrukcija procesora koja vraca staru boolean vrednost promenljive, a zatim postavlja 
	vrednost te promenljive na true (kao atomicnu operaciju)
	* ne postoji ova instrukcija na svakom racunaru, ali se moze simulirati npr. sa swap instrukcijom ili
	nekom drugom

bool TS(bool lock) {
	<bool initial = lock; lock = true; return initial;>
}

* svaki upis u deljenu promenljivu iziskuje sinhronizaciju kes memorija jezgara procesora - zato treba
minimizovati upise u deljene promenljive za bolje performanse programa
* takodje, mnogo upisa u deljenu promenljivu okupira magistralu i ne dozvoljava drugim procesima
da izadju na magistralu
* zato je dobro resenje ispod - znacajno je smanjen broj upisa u deljenu promenljivu lock

bool lock = false;
process CSi {
	while (true) {
		while (lock) skip;  /* spin dok je lock true, tj. dok je kriticna sekcija zauzeta */
		while (TS(lock)) {  /* probaj prvi da uzmes lock, tj. da zauzmes kriticnu sekciju */
			while (lock) skip;  /* spin ponovo ako nisi uspeo, tj. ako je neko drugi zauzeo kriticnu sekciju */
		}
		critical section;
		lock = false;  /* exit */
		noncritical section;
	}
}