- Konkurentno programiranje
	* procesi dele zajednicku memoriju
	* procesi komuniciraju koristeci deljene promenljive
	
- Distribuirano programiranje
	* memorija je distribuirana (procesi ne komuniciraju koriscenjem deljenih promenljivih)
	* procesi komuniciraju iskljucivo razmenom poruka
		- komunikacioni kanali
		- sanducici
		- RPC (Remote Procedure Call)
			* u Javi se ovo naziva RMI (Remote Method Invocation)
			* korisnik ne mora da zna uopste da se nalazi u distribuiranom racunarskom sistemu
			* ovo predstavlja poziv metode koja se uopste ne nalazi na nasem racunaru, ali programer to uopste ne mora da zna,
			njemu taj poziv treba da izgleda kao najobicniji poziv neke metode na njegovom racunaru - treba da bude sakrivena
			od njega implementacija RPC
		- rendezvous
			* ovaj koncept smo vec razmatrali kod Sleeping Barber Problem
	* obicno su procesi koji komuniciraju na razlicitim racunarima, ali to ni ne mora da bude slucaj
		- npr. kod Andriod mobilnih uredjaja procesi komuniciraju razmenom poruka iako su na istom racunaru
	* kod distribuiranog programiranja nema deljenih promenljivih
		- upravo zato sto svaki proces ima svoju memoriju i nije ni moguce da neki proces pristupi memoriji drugog procesa
		- zato, da bi procesi mogli da komuniciraju, definisu se operacije za slanje i prijem poruka - moracemo da se nekako zna ko salje poruku
		i ko prima poruku, gde se oni nalaze, kako se do njih dolazi, ali se mi necemo baviti time (telekomunikacionom infrastrukturom)
			* mi cemo da razmatramo kako se implementiraju komunikacioni kanali (sanducici) koji ce omoguciti komunikaciju izmedju procesa
	
- Razmena poruka (Message Passing)
	* u konkurentnom programiranju smo se vec susreli sa problemom koji lici na razmenu poruka (Atomic Broadcast - tu je jedan proces upisivao
	podatke u bafer, a ostali su citali)
	* definisacemo specijalne mrezne operacije koje ukljucuju sinhronizaciju (message passing primitives)
	* iz jednog komunikacionog kanala (sanduceta) ce tipicno jedan proces moci da cita podatke
		- objasnjenje: ljudi obicno npr. nemaju dva telefona tako da oba telefona imaju isti broj, pa da na oba telefona primaju iste poruke
		- dakle, nije predvidjeno da iz jednog komunikacionog kanala vise procesa cita podatke, vec samo jedan
	* procesi ipak mogu i da dele nekad komunikacione kanale
		- kanali su tipicno jedini objekat kog procesi mogu da dele u distribuiranom programiranju
	* razmena poruka (Message Passing) omogucava komunikaciju izmedju posiljaoca (sender) i primaoca (receiver) koriscenjem komunikacionog
	kanala
	* za sad cemo se baviti samo Unicast komunikacijom (izmedju dva procesa)
	* u distribuiranom programiranju nemamo semafore, monitore i regione, vec koristimo komunikacione kanale
	
	* osobine komunikacionog kanala:
		- cuva se redosled poruka (red postuje FIFO)
		- omogucen je atomski pristup komunikacionom kanalu
			* imacemo dve metode pomocu kojih se poruka stavlja u kanal (slanje poruke) ili dohvata iz kanala (prijem poruke)
		- moze se specificirati tip podatka koji se salje
		- komunikacioni kanali vode racuna o greskama koje mogu da se pojave
		- pretpostavicemo u nasim problemima da su komunikacioni kanali beskonacne velicine, ali svakako oni nisu predvidjeni da cuvaju veliku kolicinu
		podataka (npr. nikako ne bismo smeli da komunikacioni kanal koristimo kao bafer za cuvanje podataka kod Producer Consumer problema)
			* ukoliko preteramo sa kolicinom podataka koje pokusamo da smestimo u komunikacioni kanal, metoda za slanje poruke ce emitovati
			gresku i reci nam da slanje nije uspelo da se realizuje
			
	* postoje razne varijante razmene poruka (message passing-a)
		- asinhrona (u Javi) ili sinhrona komunikacija (u CSP-u)
			* kod asinhrone komunikacije poruka se posalje i proces odmah nastavlja dalje izvrsavanje - uopste ne ceka da drugi proces primi poruku
			* kod sinhrone komunikacije poruka se posalje i proces koji je poslao ceka dok druga strana ne javi da je primila poruku (rendezvous)
		- staticko (direktno) ili dinamicko (indirektno) imenovanje
			* kod statickog imenovanja unapred mora da se zna kome se salje poruka
			* kod dinamickog imenovanja ne mora unapred da se zna kome se salje poruka, vec se to dinamicki odredjuje
				- danas se najvise koristi dinamicko imenovanje, ali opet dosta aplikacija koristi staticko imenovanje jer znaju uvek s kim treba da
				komuniciraju (npr. YouTube, WhatsApp, Messenger uglavnom komuniciraju sa nekoliko fiksnih adresa kako bi pruzili uslugu korisniku)
		- protok informacija u jednom ili dva smera
			- u Javi cemo imati koncept socket-a (prikljucnica) koji ce se otvoriti izmedju dve strane koje komuniciraju i preko kog ce procesi
			moci da primaju i salju poruke (socket-i nam omogucavaju protok informacija u oba smera)
		- blokirajuci ili neblokirajuci komunikacioni kanali
		- razlicit broj procesa moze biti prikacen na jedan komunikacioni kanal:
			* 1-1 (Point-to-Point (P2P))
				- jedan proces salje poruku drugom procesu
			* N-1
				- vise razlicitih procesa moze da salje poruke preko istog komunikacionog kanala nekom drugom procesu (npr. vise razlicitih klijenata
				koji salju zahteve jednom istom serveru)
			* 1-N
				- ovo je u sustini broadcast - jedan proces salje poruku na komunikacioni kanal sa kog moze vise drugih procesa da je primi
			* N-N
				- vise procesa moze da salje poruke na isti komunikacioni kanal, a takodje moze i vise procesa da prima poruke sa tog kanala
					* ovo se koristi kod nekih serverskih resenja da bi mogla komunikacija da se sprovede brze
					
- Asinhrona razmena poruka (Asynchronous Message Passing)
	* deklaracija komunikacionog kanala (u njega se smesta poruka)
		- chan nazivKanala(type1 id1, ..., typen idn);
		- neophodno je precizirati tipove (to su tipovi podataka koji ce se slati putem kanala), a pisanje id-eva je opciono
	* poruke se salju i primaju pomocu komunikacionih primitiva (metoda) send i receive
		- send nazivKanala(expr1, ..., exprn);
			* expr1, ... exprn su argumenti koji se salju putem kanala (to su neki izrazi koji moraju da se sracunaju na strani posiljaoca i onda se 
			rezultati salju po vrednosti primaocu (ne mozemo da saljemo nista po referenci, sve se salje po vrednosti))
			* tipovi argumenata moraju da budu uskladjeni sa tipovima koji su u deklaraciji komunikacionog kanala
			* metoda send kod asinhrone razmene poruka je neblokirajuca - to znaci da posiljalac odmah nastavlja svoje izvrsavanje nakon slanja
			poruke, dakle ne ceka da je primalac zaista i primi
			* u nasim problemima pretpostavicemo da je kanal neogranicenog kapaciteta
				- medjutim, svejedno cemo paziti da ne preteramo sa kolicinom podataka koje stavimo u nas kanal
					* npr. kod problema Producer Consumer necemo u kanal odmah ubacivati poruku, nego cemo prvo traziti dozvolu, tj. da se proveri
					da li ima mesta u kanalu, pa tek ako ima onda cemo slati poruku
		- receive var(var1, ..., varn);
			* tipovi argumenata moraju da budu uskladjeni sa tipovima koji su u deklaraciji komunikacionog kanala
			* metoda receive kod asinhrone razmene poruka je blokirajuca - proces koji ceka da primi poruku se blokira sve dok je ne primi
	* ponekad postoji metoda empty(c) koja vraca true ukoliko je nas komunikacioni kanal prazan
		- ona moze da bude korisna da bi proces mogao, ukoliko je kanal prazan, da uzme da radi nesto korisno umesto da ceka poruku u blokiranom
		stanju, a nece je primiti sigurno dok je kanal prazan
		- necemo koristiti ovu metodu u nasim resenjima, nece biti potrebe
	* poredjenje semafora sa asinhronom razmenom poruka:
		- semafor <=> kanal
		- signal <=> send
		- wait <=> receive
		- vrednost interne semaforske promenljive <=> broj poruka u kanalu
	* komunikacioni kanal dakle moze da se iskoristi kao semafor za sinhronizaciju procesa
	
- Filteri
	* filter je proces koji ima:
		- jedan ili vise ulaznih kanala ili
		- jedan ili vise izlaznih kanala
	* filter sluzi da podaci dodju do njega preko jednog ili vise ulaznih kanala, zatim filter moze te podatke da izbaci, prosledi ih dalje 
	nepromenjene ili da ih nekako obradi pa onda tek prosledi dalje opet preko jednog ili vise izlaznih kanala
	* primer filtera su tokovi (stream) i protok podataka (dataflow)
	* filtere treba povezati tako da nam svi oni zajedno izvrsavaju neku operaciju od interesa
		- npr. moze vise filtera zajedno da nam radi merge sort
	
- Filterski proces - mailbox
	* mozemo ga nazvati agregator - on skuplja vise podataka koji dolaze, i kada se napuni njegov interni bafer gde smesta te podatke, onda se
	oni prosledjuju nekom drugom procesu svi odjednom
	
const int MAXLINE = ...;  // kapacitet internog bafera	
chan inputChannel(char);
chan outputChannel(char[MAXLINE]);

void char_to_line() {
	char line[MAXLINE];
	int i = 0;
	while (true) {
		receive input(line[i]);
		while (line[i] != 'CR' && i < MAXLINE) {
			i++;
			receive input(line[i]);
		}
		line[i] = EOL;  // EOL - End Of Line
		send output(line);
		i = 0;
	}
}

- Filteri - mreza sa sortiranje
	* ulazni kanal prima n vrednosti koje treba da budu sortirane, a na izlazni kanal se salju sortirane vrednosti
	* na 3 razlicita nacina mozemo da znamo koliko ima vrednosti koje treba sortirati:
		1) n moze da bude poznato unapred kao neka konstanta (u compile time-u je znamo)
		2) n moze da bude poslato kao prva vrednost u nizu
		3) moze da se zna kad smo stigli do kraja primljenog niza tako sto proces koji salje niz postavi na kraju neku specijalnu vrednost (sentinel
		value na osnovu koje znamo da smo dosli do kraja - npr. EOS - End Of Stream ili EOL - End Of Line)
	* sortiranje na jednom racunaru je ono cime smo se do sada bavili i ono se obavlja u 3 koraka:
		1) primi sve podatke koje treba sortirati
		2) sortiraj primljene podatke
		3) posalji nazad sortiran niz
	* procese mozemo povezati na dva nacina:
				1) u lanac (pipeline)
				2) u mrezu za stapanje (ona ima veci broj cvorova na ulazu, a manji broj cvorova na izlazu - hijerarhijska struktura)
	* od filtera mozemo napraviti mrezu za sortiranje i mrezu za stapanje
		- mreza za sortiranje je mreza procesa koji se izvrsavaju u paraleli koji obavljaju delove sortiranja niza
		- mreza za stapanje od dva ili vise sortiranih nizova formira jedan veci sortirani niz
		
* u algoritmima i strukturama podataka smo se uglavnom fokusirali da minimizujemo vreme obrade
	- u distribuiranom programiranju moze se desiti da uopste vreme obrade ne bude kritican faktor, vec vreme komunikacije
		* to je slucaj zato sto su operacije send i receive vrlo spore, cak mnogo sporije nego npr. operacije sa semaforima
			- dakle treba minimizovati pozive ovih operacija
		
- Filterska mreza za sortiranje sa binarnim stablom
	* posto je u pitanju binarno stablo, ovakav filter ima dva ulazna kanala
	* ukoliko npr. zelimo da sortiramo niz neopadajuce, filter ce prosledjivati dalje na izlazni kanal manji element od dva koja su stigla na ulaznim
	kanalima
	* varijante:
		- filter pamti sve elemente trajno koje je primio (nije mnogo pametno)
		- filter pamti uvek samo jedan element od dva koja je primio, a jedan prosledjuje dalje
		- filter pamti 2 ili vise elemenata koje je primio
	* ova filterska mreza je pogodna kada je velicina niza n stepen broja 2
		- tada se lako racuna koji proces treba kom elementu niza da pristupi
	
	* mi cemo raditi sa binarnim stablom od n-1 procesa koji treba da sortiraju niz duzine n
		- ovo je ustvari filterska mreza za stapanje
		- svaki proces ce da ima dva ulazna kanala i jedan izlazni
		- u tom slucaju je nase stablo simetricno - svi cvorovi su identicni i imamo potpuno balansirano stablo
			* to ne mora uvek da bude slucaj ukoliko je duzina niza manja od n
		- na pocetku cemo imati n/2 procesa koji primaju na svoja dva ulazna kanala po dva elementa niza i nakon svakog od njih znak EOS da se 
		naznaci kraj toka, a onda ti procesi treba da na svom izlaznom kanalu proslede niz od ova dva elementa u odgovarajucem poretku i na kraju
		tog niza takodje da postave znak EOS za kraj toka
		- treba paziti uvek da nam u komunikacionim kanalima ne ostane nekakvo djubre, tj. neke poslate poruke koje niko nije primio
			* to moze da napravi problem jer onda kada neki proces zaista treba da primi neku poruku, ukoliko je ostalo neko djubre on moze da
			naidje na znak EOS u njemu i da shvati da je to kraj poruke, a zapravo uopste nije primio tu novu poruku vec staru koja je neko djubre
			
	* ne moraju uvek svi cvorovi nase filterske mreze da budu isti
			
chan in1(int), in2(int), out(int);
void merge() {
	int v1, v2;
	receive in1(v1);
	receive in2(v2);
	while (v1 != EOS && v2 != EOS) {
		if (v1 < v2) {
			send out(v1);
			receive in1(v1);
		} else {
			send out(v2);
			receive in2(v2);
		}
		if (v1 == EOS) {
			while (v2 != EOS) {
				send out(v2);
				receive in2(v2);
			}
		}
		if (v2 == EOS) {
			while (v1 != EOS) {
				send out(v1);
				receive in1(v1);
			}
		}
	}
	send out(EOS);
}

- Staticko i dinamicko imenovanje
	* kako u proslom primeru procesi mogu da pristupe svojim ulaznim kanalima (in1, in2) i izlaznom kanalu (out)?
		1) proces moze sam da im pristupi na osnovu svog identifikatora (staticko imenovanje)
			- svi kanali su globalan niz i identifikator svakog procesa se preslikava u identifikatore njegovih kanala
		2) neko ih prosledi procesu (dinamicko imenovanje)
			- svi kanali su globalni, ali neki glavni proces kreira kanale i prosledjuje ih odgovarajucim procesima pri njihovom kreiranju
			
- Klijent-server arhitektura
	* kod ove arhitekture se veci broj procesa (klijenata) obraca jednom procesu (serveru) koji neprekidno obradjuje njihove zahteve i 
	prosledjuje nazad odgovore
	* ulazni kanal (request) servera je takav da moze da primi poruke od vise razlicitih procesa (klijenata)
	* server odgovara klijentima preko svog izlaznog kanala (reply)
	* ukoliko se koristi staticko imenovanje
		- imamo fiksan broj kanala i klijenti moraju da salju svoj identifikator da bi server mogao da im odgovori
	* ukoliko se koristi dinamicko imenovanje
		- svaki klijent kreira proces sa privatnim reply kanalom na koji ce mu server slati odgovor
	* mi cemo koristiti staticko imenovanje - klijent ce uvek morati da posalje svoj identifikator
	* server mora da zna kome treba da odgovori
		- to cemo u nasem slucaju resavati tako sto ce klijent morati da se predstavi serveru tako sto ce mu proslediti svoj identifikator kao deo
		svoje poruke
		- u programskom jeziku Java:
			* ukoliko imamo dugozivecu konekciju izmedju klijenta i servera, pomocu porta i IP adrese sa obe strane ce se
			tacno znati ko s kim komunicira (te podatke mozemo sami da dobijemo iz naseg komunikacionog kanala)
			* ukoliko imamo kratkozivecu konekciju izmedju klijenta i servera, klijent mora da posalje serveru svoj identifikator
			* server salje odgovor na isti kanal preko kog je dobio zahtev - dakle taj kanal ce biti request/reply kanal istovremeno
			
* komunikacioni kanali request i reply nisu deljene promenljive kao sto smo ranije navikli u konkurentnom programiranju, vec su napisani ovako
globalno samo da bismo naznacili da svi barataju sa takvim kanalima i da bismo lakse ispratili kod, ali se uopste ne radi o istim kanalima u
razlicitim delovima koda - npr. u funkciji server i client se barata sa kanalima request i reply ali uopste se ne radi o istim kanalima vec svaki
proces ima svoj par ovih kanala
	- zato ih cak ne moramo ni nazivati na isti nacin u razlicitim delovima koda, ali onda mora postojati neki glavni proces (konfiguracioni menadzer)
	koji ce da dohvati na osnovu nekog identifikatora komunikacioni kanal koji je na odredjenom mestu u kodu potreban - tu bismo imali indirektno 
	imenovanje jer bi taj nas naziv odredjenog kanala ustvari upucivao na kanal koji nam je dohvatio konfiguracioni menadzer
		* u Javi na osnovu IP adrese i porta moze da se dohvati odgovarajuci komunikacioni kanal

* mi smo ovde zapravo napravili server sa samo jednom operacijom
	- server u jednom trenutku moze da obavlja samo jednu ovakvu operaciju
		* zato je ovakva operacija ekvivalentna monitorskoj operaciji u konkurentnom programiranju
	- ovako nas napravljen server predstavlja jedan aktivan monitor sa jednom operacijom

chan request(int clientId, types of input values);
chan reply[n] (types of results);

void server() {
	int clientId;
	declaration of permanent variables;
	initialization code;
	while (true) {
		receive request(clientId, input variables);
		results = f(input variables, permanent variables);
		send reply[clientId] (results); 
	}
}

void client(int clientId) {
	send request(clientId, value arguments);
	receive reply[clientId] (result arguments);
}

- Klijent-server arhitektura - aktivni monitori
	* aktivni monitori predstavljaju simulaciju monitora iz konkurentnog programiranja koriscenjem serverskih procesa i tehnike razmene poruka
	(message passing)
	* osobine aktivnih monitora:
		- imaju jedan tok kontrole
			* kada bi imao vise tokova kontrole to bi onda bilo RPC (Remote Procedure Call), a ne aktivan monitor
		- imaju jedan ulazni kanal
	* nit aktivnog monitora ne bi smela nikada da se zablokira jer bi onda aktivan monitor potpuno prestao da radi upravo jer je to njegova
	jedina nit (nastao bi deadlock)
	* nedeljiv pristup aktivnom monitoru je garantovan samim tim sto on ima samo jedan jedini tok kontrole
	* analogije izmedju monitora sa jednom metodom iz konkurentnog programiranja i aktivnih monitora u distribuiranom programiranju:
		- stalne promenljive <=> lokalne promenljive 
		- pozivi procedura (monitor.procedura()) <=> send request(); receive reply();
		- ulaz u monitor (entry queue) <=> receive request();
		- izlaz iz monitora <=> send reply();
		
- Aktivni monitori sa vise operacija
	* kompleksnije je jer ima vise operacija
	* razliciti su argumenti, operacije i rezultati
		- argumenti i rezultati se razlikuju po tipovima i broju parametara
	* kada je server implementiran kao aktivan monitor sa vise operacija, tada klijent pored svog identifikatora treba da posalje i koju 
	operaciju zeli da server izvrsi, kao i potrebne argumente za tu operaciju
		- klijent odgovor ocekuje na svom odredjenom reply kanalu koji je uparen sa njegovim identifikatorom
	* ovo se zove event-driven arhitektura
		- danas je ona dosta popularna zbog velike brzine
		- u takvoj arhitekturi uvek postoji neki red iz kog ciklicno izvlacimo zahteve koje treba da obavimo, odradimo sta treba pomocu argumenata
		koji su nam takodje prosledjeni i onda rezultat vratimo
		- sistemi izgradjeni na ovoj arhitekturi bi trebalo da budu dosta brzi
			* to je upravo jer nas aktivan monitor ima samo jednu nit i uopste nema blokiranja niti vec ona konstantno radi, prima zahteve, obradjuje
			koje moze, a one koje ne moze stavlja u red i obradjuje cim bude mogla
		- kod naseg aktivnog monitora postoji jedna jedina nit (tok kontrole) i ona nikada ne bi smela da se zablokira - ako bi se ona zablokirala,
		server bi potpuno prestao da radi (nastao bi deadlock) upravo jer je to jedina njegova nit
	* analogija izmedju monitora sa vise metoda iz konkurentnog programiranja i aktivnog monitora sa vise operacija iz distribuiranog programiranja:
		- identifikatori razlicitih procedura <=> tipovi operacije prosledjeni preko request kanala
		- tela procedura <=> delovi case iskaza u zavisnosti od tipa operacije koji je prosledjen
	
	type op_kind = enum(op_1, ..., op_n);
	type arg_type = union(arg_1, ..., arg_n);
	type result_type = union(res_1, ..., res_n);
	chan request(int clientId, op_kind, arg_type);
	chan reply[n] (result_type);
	
	// server implementiran kao aktivni monitor sa vise operacija
	void server() {
		int clientId;
		op_kind kind;
		arg_type args;
		result_type results;
		declaration of permanent variables;
		initialization code;
		while (true) {
			receive request(clientId, kind, args);
			switch (kind) {
				case op_1:
					body of op_1;
					break;
				...
				case op_n:
					body of op_n;
					break;
			}
			send reply[clientId] (results);
		}
	}
	
	void client(int clientId) {
		arg_type myArgs;
		result_type myResults;
		set value arguments in myArgs;
		send request(clientId, op_j, myArgs);
		receive reply[clientId] (myResults);
	}
	
- FIFO Semaphore (napravljen pomocu monitora u konkurentnom programiranju)
	* simuliran pomocu aktivnog monitora u distribuiranom programiranju

chan request(int clientId, string operationKind);
chan reply[] (dummyType);

void server() {
	int s = 0;
	// simuliramo monitorsku uslovnu promenljivu pomocu reda u koji cemo samo smestati id-eve klijenata koje bismo blokirali u konkurentnom
	// programiranju (dodavanje u red pos ovde radimo umesto blokiranja na uslovnoj promenljivoj)
	queue pos;
	int clientId;
	string operationKind;
	while (true) {
		receive request(clientId, operationKind);
		switch (operationKind) {
			case "semWait":
				if (s == 0) {
					pos.put(clientId);
				} else {
					s--;
					send reply[clientId] (dummyObject);
				}
				break;
			case "semSignal":
				if (pos.size() == 0) {
					s++;
					// ovaj send reply ovde nije ni morao da se uradi jer poziv metode signal u semaforu nije blokirajuca operacija, pa to znaci da onaj
					// koji je pozvao signal uopste ni ne ceka nikakav odgovor vec je asinhrono pozvao signal i nastavio dalje sa izvrsavanjem
					send reply[clientId] (dummyObject);
				} else {
					send reply[pos.remove(0)] (dummyObject);
				}
				break;
		}
	}
}