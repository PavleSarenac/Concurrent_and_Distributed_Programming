- monitori
	* monitor je objekat koji drugi procesi mogu da koriste za sinhronizaciju pozivajuci njegove metode
	* zelimo da napravimo apstrakciju - sakrili smo potpuno podatke koji se odnose na sinhronizaciju (to ce biti privatni atributi monitora i njima
	ne mogu procesi da pristupaju)
	* metode monitora implicitno garantuju medjusobno iskljucivanje
	* uslovna sinhronizacija je kod monitora implementirana pomocu uslovnih promenljivih (u prve 4 verzije Jave je postojala samo jedna
	uslovna promenljiva - this, ali je nadalje to izmenjeno tako da ih moze biti i vise)
	
- modularizacija
	* u konkurentnom programiranju monitori su pasivni objekti - u njima se samo cuvaju podaci, ali oni nisu niti i nemaju svoj tok kontrole
	* aktivni procesi pozivaju metode monitora - sva sinhronizacija je sakrivena u monitoru za programere aktivnih procesa, tako da ovi
	programeri ne moraju nista da znaju o tome kako se obavlja sinhronizacija, vazno im je samo da je ona obezbedjena
	* programeri monitora mogu da menjaju implementaciju monitora kako zele, sve dok ti monitori sve vreme obezbedjuju sinhronizaciju - 
	ako je to slucaj, na programere aktivnih procesa nikako nece uticati ako je programer monitora promenio njegovu implementaciju
	* monitori olaksavaju raspodelu odgovornosti medju programerima - jedni ce se baviti konkurentnoscu koda, a drugi funkcionalnoscu
	
- struktura monitora
monitor monitorName {
	deklaracija stalnih promenljivih  // zadrzavaju svoju vrednost kad izadjemo iz neke metode (njima ne moze aktivni proces da pristupi)
	inicijalizacija  // konstruktor
	procedure  // metode nad kojima cemo raditi sinhronizaciju (samo njima moze aktivni proces da pristupi)
}

- enkapsulacija
	* pristup monitoru je moguc samo kroz pozive metoda monitora
	* nije moguce referencirati privatne atribute monitora izvan njega
	* stalne promenljive monitora su inicijalizovane pre poziva njegovih metoda
	* programer monitora ne moze da zna redosled pozivanja monitorskih metoda - korisnik monitora moze da ga lose koristi - 
	postoji predvidjen nacin koriscenja monitora
	* monitorska invarijanta - nesto sto uvek mora da vazi za monitor
	
- medjusobno iskljucivanje
	* kada neki aktivni proces udje u monitor, on ima ekskluzivno pravo koriscenja celog objekta monitora (svih njegovih metoda)
	
- uslovne promenljive
	* monitori imaju uslovne promenljive, pri cemu svaka uslovna promenljiva ima red procesa koji su zablokirani na njoj
	* cond cv;  // cv je uslovna promenljiva na kojoj se procesi blokiraju
	* wait(cv);  // proces koji pozove metodu ovu metodu se BEZUSLOVNO blokira na uslovnoj promenljivoj cv i odrice se ekskluzivnog prava pristupa monitoru
	* signal(cv);  // budi se proces koji je na pocetku reda cekanja na uslovnoj promenljivoj cv (ako je red blokiranih procesa prazan, nema efekta)
	
- signal discipline
	* Signal and Continue (nonpreemptive)
		- u Javi je ovo slucaj - kada neki proces pozove signal nad nekom uslovnom promenljivom unutar monitora, on zadrzava ekskluzivno pravo 
		pristupa monitoru, a proces kojeg je probudio se prebacuje iz reda blokiranih na toj uslovnoj promenljivoj na red blokiranih na ulazu u
		monitor (entry queue)
		- posto moze da prodje dosta vremena izmedju trenutka kada je proces probudjen i prebacen u entry queue i trenutka kada on zapravo
		udje u monitor, moguce je da se promenilo u medjuvremenu stanje monitora - zato probudjeni proces mora uslove unutar monitora da
		proverava u while petlji umesto sa if naredbom (mada to i ne mora uvek tako da se radi, moze se iskoristiti i tehnika Passing the Condition)
		- samo kod monitora sa disciplinom Signal and Continue postoji metoda notifyAll() jer se ona ne kosi sa logikom ove discipline koja kaze
		da probudjeni proces ide u Entry Queue, tako da nema razloga da ne mogu da se probude i svi procesi na nekoj uslovnoj promenljivoj
		jer ce oni svakako ici u Entry Queue i nije garantovan redosled ulaska u monitor nikome
		- kod ovakvih monitora ima 5 karakteristicnih situacija:
			1) ulazak u monitor
			2) izlazak iz monitora
			3) cekanje na uslovnoj promenljivoj
			4) budjenje jednog procesa na uslovnoj promenljivoj
			5) budjenje svih procesa na uslovnoj promenljivoj
		
	* Signal and Wait (preemptive)
		- kada neki proces pozove signal nad nekom uslovnom promenljivom unutar monitora, on prepusta ekskluzivno pravo pristupa monitoru
		probudjenom procesu, a on odlazi u red blokiranih na ulazu u monitor (entry queue)
		- proces koji je pozvao signal treba da proverava uslove u monitoru u while petlji umesto sa if naredbom (isto obrazlozenje kao za
		probudjeni proces kod Signal and Continue)
		- kod monitora sa disciplinom Signal and Wait ne postoji metoda notifyAll(), jer se kosi sa logikom ove discipline koja kaze da se odmah
		prepusta ekskluzivno pravo pristupa konkretnom probudjenom procesu, pa nema potrebe za metodom notifyAll() jer se budi uvek jedan
		proces
		- kod ovakvih monitora imaju 4 karakteristicne situacije:
			1) ulazak u monitor
			2) izlazak iz monitora
			3) cekanje na uslovnoj promenljivoj
			4) budjenje jednog procesa na uslovnoj promenljivoj
		
	* Signal and Urgent Wait
		- isto kao Signal and Wait, samo u ovom slucaju onaj proces koji je pozvao signal, pa napustio monitor, ulazi u monitor cim probudjeni proces
		izadje iz monitora (garantovano je odmah sledeci, a kod Signal and Wait to nije slucaj)
		
- dijagram stanja za monitore
	* stanja:
		1) entry queue (red cekanja na ulazu u monitor)
		2) executing the monitor (unutrasnjost monitora)
		3) condition variable queues (redovi cekanja na uslovnim promenljivim unutar monitora)
	* prelazi izmedju stanja:
		(1) ---> (2)
			- ukoliko je monitor slobodan, proces moze da izadje iz entry queue i udje u monitor
			- taj proces onda dobija ekskluzivno pravo pristupa monitoru
			- ako se taj proces nigde ne blokira u monitoru, on ce odraditi sta ima i napustiti monitor
		(2) ---> (3)
			- ukoliko proces naidje u monitoru na poziv wait metode nad nekom uslovnom promenljivom, on bezuslovno napusta monitor i prebacuje
			se u red blokiranih procesa na toj uslovnoj promenljivoj
		(3) ---> (1)
			- ukoliko neki proces pozove Signal and Continue nad uslovnom promenljivom, onda ce se probudjeni proces prebaciti iz reda cekanja
			na uslovnoj promenljivoj na red cekanja na ulazu u monitor
		(2) ---> (1), (3) ---> (2)
			- ukoliko neki proces pozove Signal and Wait nad uslovnom promenljivom, onda ce probudjeni proces dobiti ekskluzivno pravo pristupa
			monitoru, a proces koji je pozvao signal ce napustiti monitor i otici u red cekanja na ulazu u monitor
	* nije garantovan FIFO redosled prilikom budjenja procesa sa redova cekanja (u programskom jeziku Java je tako)
	
- redovi u monitorima
	* monitori odrzavaju dosta razlicitih redova cekanja:
		- Entry Queue
			* ovo je red cekanja na ulazu u monitor - sluzi da obezbedi medjusobno iskljucivanje za pristup monitoru
		- CV (Condition Variable) Queues
			* za svaku uslovnu promenljivu postoji po jedan red cekanja na kojem procesi cekaju na ispunjenje tog uslova
		- Urgent Queue
			* ako monitor ima Signal and Urgent Wait disciplinu, na ovom redu ce cekati procesi koji su pozvali signal pa napustili monitor i
			oni imaju prioritet za ulazak u monitor u odnosu na procese koji cekaju na Entry Queue
			
- implementacija Signal and Urgent Wait monitora pomocu semafora
	* semafori mutex, next i CV.sem predstavljaju jedan raspodeljeni binarni semafor (samo jedan od njih moze u jednom trenutku imati
	vrednost 1) i svi oni stite pristup monitoru
	* koristimo tehniku predaje stafetne palice i raspodeljenog binarnog semafora da bismo implementirali monitor
	* nedostatak ove implementacije je sto nismo omogucili da se iz jedne monitorske metode zovu druge monitorske metode

	* monitor:
		wait(mutex);  // mutex je semafor koji predstavlja Entry Queue
		// najvise jedan proces aktivan u monitoru, medjusobno iskljucivanje monitorskih procedura
		...
		tela monitorskih procedura
		...
		if (next.count > 0) {  // next.count predstavlja brojac blokiranih procesa na Urgent Queue
			signal(next);  // next je semafor koji predstavlja Urgent Queue; budjenje procesa iz tog reda
		} else {
			signal(mutex);  // budjenje procesa iz Entry Queue
		}
		
	* cekanje na uslovnoj promenljivoj (CV):
		CV.count++;  // CV.count je brojac blokiranih procesa na uslovnoj promenljivoj CV
		if (next.count > 0) {  // prioritet imaju procesi iz Urgent Queue
			signal(next);  // budjenje procesa iz Urgent Queue
		} else {
			signal(mutex);  // budjenje procesa iz Entry Queue
		}
		wait(CV.sem);  // bezuslovno blokiranje procesa na uslovnoj promenljivoj CV
		CV.count--;
		
	* signaliziranje na uslovnoj promenljivoj (CV):
		if (CV.count > 0) {  // signal ima efekta samo ako postoji bar jedan zablokiran proces na uslovnoj promenljivoj CV
			next.count++;  // povecavamo brojac zablokiranih procesa na Urgent Queue jer ce tekuci proces da ode na njega
			signal(CV_sem);  // tekuci proces budi jedan proces sa uslovne promenljive CV i predaje mu ekskluzivno pravo pristupa monitoru
			wait(next);  // tekuci proces napusta monitor i ide na Urgent Queue
			next.count--;  // smanjujemo brojac zablokiranih procesa na Urgent Queue
		}
		
- implementacija Signal and Wait monitora pomocu semafora
	* monitor:
		wait(mutex);
		// najvise jedan proces aktivan u monitoru, medjusobno iskljucivanje monitorskih procedura
		...
		tela monitorskih procedura
		...
		signal(mutex);
		
	* cekanje na uslovnoj promenljivoj (CV):
		CV.count++;
		signal(mutex);
		wait(CV.sem);
		CV.count--;
		
	* signaliziranje na uslovnoj promenljivoj (CV):
		if (CV.count > 0) {
			signal(CV.sem);
			wait(mutex);
		}
		
* ekskluzivno pravo pristupa monitoru se moze napustiti na dva nacina:
		1) kada proces zavrsi izvrsavanje metode monitora
		2) kada proces pozove metodu wait nad uslovnom promenljivom - bezuslovno se blokira na njoj
* ne treba se oslanjati na to da je obezbedjen FIFO redosled na uslovnim promenljivama - cesto nije, pa ako nam treba mi moramo da ga
obezbedimo
		
- Semafor napravljen preko monitora
	* u nekim programskim jezicima prvo su napravljeni monitori, pa se onda preko njih implementiraju semafori (npr. u Javi)
	
	* pretpostavka u ovom primeru je da monitor ima Signal and Continue disciplinu
		- to znaci da proces koji se probudi na uslovnoj promenljivoj ide u entry queue, a onaj sto ga je probudio nastavlja da izvrsava
		monitorsku metodu
		- pretpostavka je da nije garantovan FIFO redosled ni na entry queue, a ni na uslovnoj promenljivoj pos, tako da uopste nije garantovano
		da je ovaj semafor FIFO
	* vrlo je vazno da se uslov s == 0 u metodi semWait proverava u while petlji a ne if strukturom
		- to je slucaj zato sto moze da prodje dosta vremena izmedju trenutka kada je proces prvi put proverio uslov s == 0 i zablokirao se
		na uslovnoj promenljivoj pos i trenutka kada proces zaista nastavi svoje izvrsavanje u monitorskoj metodi - moguce je da su u medjuvremenu
		drugi procesi izvrsavali monitorske metode i menjali vrednost semaforske promenljive s, pa je treba proveravati u petlji za svaki slucaj
		ako je potrebno da se probudjeni proces ipak ponovo zablokira
		- moze da prodje dosta vremena zato sto se proces prvo blokira na uslovnoj promenljivoj pos, zatim kada se probudi on se prebaci u
		entry queue i uopste nije poznato kada ce on zaista dobiti ponovo ekskluzivno pravo pristupa monitoru i nastaviti svoje izvrsavanje
		monitorske metode tamo gde je stao
		- kada ne bismo ovo radili, bilo bi moguce da promenljiva s dobije vrednost manju od nule, sto je nekonzistentno stanje i onda nam
		vise ne bi funkcionisao ovako napravljen semafor
		
	* kada bi monitor iz primera imao Signal and Wait disciplinu, onda bi uslov s == 0 mogao da se proverava if strukturom umesto u while 
	petlji zato sto kod ove discipline probudjeni proces odmah dobija ekskluzivno pravo pristupa monitoru, dok onaj sto ga je probudio ide u
	entry queue
		- pretpostavka je da je garantovan FIFO redosled na uslovnoj promenljivoj pos (ovo uvek treba proveriti u konkretnom programskom jeziku)
			* samo pod ovom pretpostavkom nije neophodna provera uslova s == 0 jer samo tada znamo zasigurno da niko nije mogao da umanji
			promenljivu s pre nas - to je zato sto smo nakon naseg blokiranja sigurno mi sledeci koji cemo je umanjiti
		- tada smo onda sigurni da probudjeni proces sme da izvrsava monitorsku metodu jer nije mogla da se promeni semaforska promenljiva
		od trenutka kada je on probudjen do trenutka kada on dobije ekskluzivno pravo pristupa monitoru (posto je proteklo vreme izmedju ta
		dva trenutka jednako nuli)
	
monitor Semaphore {
	int s = 0;  // interna semaforska promenljiva
	cond pos;  // uslovna promenljiva
	procedure semWait() {
		while (s == 0) {  // ovde moze if umesto while ako monitor ima disciplinu Signal and Wait
			wait(pos);  // monitorska metoda wait bezuslovno blokira proces na uslovnoj promenljivoj pos
		}
		s = s - 1;
	}
	procedure semSignal() {
		s = s + 1;
		signal(pos);  // monitorska metoda signal budi jedan blokirani proces sa uslovne promenljive pos i stavlja ga u entry queue
	}
}

- Semafor napravljen preko monitora (pomocu tehnike Passing the Condition)
	* ovde nema provere uslova s == 0 u while petlji cak ni za disciplinu monitora Signal and Continue
		- nema potrebe jer kad god da zaista oblokirani proces nastavi svoje izvrsavanje monitorske metode, on nece moci da dovede vrednost
		promenljive s u nekonzistentno stanje (da dobije negativnu vrednost) jer se promenljiva s uopste ne modifikuje nakon budjenja procesa (ni
		u metodi semSignal, ni u metodi semWait)
	* ovo funkcionise za obe discipline monitora (Signal and Continue i Signal and Wait)
	* kod ove tehnike proces p1 koji budi proces p2 proverava da li proces p2 moze da se probudi (proverava da li nije prazan red blokiranih
	procesa na uslovnoj promenljivoj pos) i dodatno ako moze, proces p1 ce da uradi posao koji bi inace uradio proces p2 nakon budjenja (s = s - 1)
		- medjutim, posto se u metodi semSignal do sad bezuslovno radilo s = s + 1, a sada prilikom budjenja nekog procesa bi se dodatno radilo i
		s = s - 1, ocigledno je da je ovo isti efekat kao da nismo dirali promenljivu s, tako da u slucajevima kada red blokiranih procesa na prome-
		nljivoj pos nije prazan, nema potrebe da menjamo promenljivu s, vec je samo dovoljno da se probudi jedan proces iz tog reda
	* ova tehnika ne moze bas uvek da se primeni
		- kod problema proizvodjaca i potrosaca (Producer and Consumer)
			* tu ne moze proces koji ubacuje u bafer (proizvodjac) da odradi posao za onog koji treba to da preuzme iz bafera (potrosaca), jer 
			potrosac mora to sto preuzme da vraca kao povratnu vrednost
	* ako je uslovna promenljiva pos FIFO, onda je i semafor garantovano FIFO

monitor Semaphore {
	int s = 0;
	cond pos;
	procedure semWait() {
		if (s == 0) {
			wait(pos);
		} else {
			s = s - 1;
		}
	}
	procedure semSignal() {
		if (queueEmpty(pos)) {
			s = s + 1;
		} else {
			signal(pos);
		}
	}
}

* Metode koje cemo koristiti
	- wait(cv)
		* bezuslovno blokira tekuci proces na uslovnoj promenljivoj cv
	- signal(cv)
		* ukoliko ima blokiranih procesa na uslovnoj promenljivoj cv, odblokira jedan, a ako ih nema onda nema efekta
	- empty(cv)
		* proverava da li je red blokiranih procesa na uslovnoj promenljivoj cv prazan (vraca true ako jeste)
	- queue(cv)
		* proverava da li red blokiranih procesa na uslovnoj promenljivoj cv nije prazan (vraca true ako nije)
	- wait(cv, rank)
		* isto radi sto i wait(cv), pri cemu dodatno i postavlja prioritet blokiranom procesu koji utice na to kad ce se on probuditi
		* sto je manji rank, veci je prioritet
		* ova metoda ne postoji u svim programskim jezicima (u Javi npr. nema, nego je u Javi drugi argument broj milisekundi koliko maksimalno
		sme da bude blokiran proces)
	- signal_all(cv)
		* isto radi sto i signal(cv), pri cemu budi sve blokirane procese ukoliko ih ima
		* ova metoda ima smisla samo kod monitora sa disciplinom Signal and Continue
			- nema smisla kod monitora sa disciplinom Signal and Wait jer kod njih budimo tacno jedan blokirani proces koji odmah dobija ekskluzivno 
			pravo pristupa monitoru
	- minrank(cv)
		* dohvata prioritet procesa koji ima najveci prioritet od blokiranih procesa na uslovnoj promenljivoj cv
		
- Bounded buffer
	* da bi radilo i za disciplinu Signal and Continue, uslovi count == n i count == 0 moraju da se proveravaju u while petlji
	* za Signal and Wait disciplinu bi mogao da stoji if umesto while
	* ovo resenje radi i za Signal and Continue i za Signal and Wait disciplinu
	* u ovom problemu nema smisla da primenimo tehniku prosledjivanja uslova (Passing the Condition)
		- u ovoj tehnici proces koji budi druge procese vodi racuna o njima tako sto obavlja njihov posao umesto njih
		- ovde to nema smisla jer je upravo poenta da potrosac radi svoj posao, dakle da uzima proizvode iz bafera i vraca 
		ih kao povratnu vrednost, a proizvodjac treba da pravi proizvode i smesta ih u bafer

monitor BoundedBuffer {
	typeT buf[n];
	int front = 0, rear = 0, count = 0;
	cond empty, full;
	procedure produce(typeT data) {
		while (count == n) {
			wait(empty);
		}
		buf[rear] = data;
		rear = (rear + 1) % n;
		count++;
		signal(full);
	}
	procedure consume(typeT &result) {
		while (count == 0) {
			wait(full);
		}
		result = buf[front];
		front = (front + 1) % n;
		count--;
		signal(empty);
	}
}

- Readers/Writers (broadcast signal)
	* vrlo je vazno da u funkciji releaseRead prvo proverimo da li je numOfReaders postao 0 i da samo u tom slucaju budimo 
	pisca koji ceka (ako takav postoji)
		- ako bismo bezuslovno uvek radili signal(okWrite) napravili bismo dva problema:
			1) ako numOfReaders nije 0, onda ce se probudjeni pisac opet zablokirati - suvisno budjenje i ponovno blokiranje 
			procesa (veliki rezijski troskovi) 
			2) ako redovi blokiranih procesa na uslovnim promenljivama postovali FIFO redosled, onda bismo besmislenim budjenjem 
			pisca i njegovim ponovnim blokiranjem njega prebacili na sam kraj tog reda i tako bismo poremetili FIFO redosled
	* vrlo bitno da u funkciji releaseWrite pozivamo signal_all nad uslovnom promenljivom za citaoce
		- kada bismo pozvali samo signal, odblokirao bi se samo jedan citalac, a moze da ih ima vise blokiranih, pa bi moglo da dodje do deadlock-a
		- budimo sve blokirane citaoce i jednog pisca, i time ih prebacujemo u entry queue i od njegove implementacije zavisi ko ce sledeci
		dobiti ekskluzivno pravo pristupa monitoru (ne dajemo prednost ni citaocima ni piscima ovde)
	* nema poente da se zove signal_all nad uslovnom promenljivom za pisce jer uvek moze maksimalno jedan pisac da pise, dok ima smisla
	zvati signal_all nad uslovnom promenljivom za citaoce jer moze vise njih istovremeno da cita
	* ovo resenje je napravljeno za Signal and Continue disciplinu

monitor ReadersWriters {
	int numOfReaders = 0, numOfWriters = 0;
	cond okRead, okWrite;
	
	procedure requestRead() {
		while (numOfWriters > 0) {
			wait(okRead);
		}
		numOfReaders++;
	}
	
	procedure releaseRead() {
		numOfReaders--;
		if (numOfReaders == 0) {
			signal(okWrite);
		}
	}
	
	procedure requestWrite() {
		while (numOfReaders > 0 || numOfWriters > 0) {
			wait(okWrite);
		}
		numOfWriters++;
	}
	
	procedure releaseWrite() {
		numOfWriters--;
		signal(okWrite);
		signal_all(okRead);
	}
	
}

- Readers/Writers (Passing the Condition)
	* ovo resenje radi samo pod uslovom da uslovna promenljiva ok postuje FIFO redosled
		- jer su samo u tom slucaju onda ispravno poredjani blokirani procesi na uslovnoj promenljivoj ok i karakteri u listi
		(svaki karakter odgovara blokiranom procesu na istoj poziciji - 'R' za citaoce, 'W' za pisce)
	* ako i entry queue postuje FIFO, onda kompletan monitor obezbedjuje FIFO redosled, u suprotnom nemamo pojma kojim ce
	redom probudjeni procesi zaista ulaziti u monitor
	* ovde koristimo tehniku Passing the Condition, sto znaci da proces koji budi drugi proces radi posao umesto njega 
	(u ovom primeru to je inkrementiranje brojaca numOfReaders ili numOfWriters)
	
monitor ReadersWriters {
	int numOfReaders = 0, numOfWriters = 0;
	cond ok;
	List list;
	
	procedure requestRead() {
		if (numOfWriters > 0 || list.size() > 0) {
			list.add('R');
			wait(ok);
		}
		numOfReaders++;
	}
	
	procedure releaseRead() {
		numOfReaders--;
		while (list.size() > 0) {
			if (list.get(0) == 'R' && numOfWriters == 0) {
				list.remove(0);
				numOfReaders++;
				signal(ok);
			} else if (list.get(0) == 'W' && numOfReaders == 0 && numOfWriters == 0) {
				list.remove(0);
				numOfWriters++;
				signal(ok);
			} else {
				break;
			}
		}
	}
	
	procedure requestWrite() {
		if (numOfReaders > 0 || numOfWriters > 0 || list.size() > 0) {
			list.add('W');
			wait(ok);
		}
		numOfWriters++;
	}
	
	procedure releaseWrite() {
		numOfWriters--;
		while (list.size() > 0) {
			if (list.get(0) == 'R' && numOfWriters == 0) {
				list.remove(0);
				numOfReaders++;
				signal(ok);
			} else if (list.get(0) == 'W' && numOfReaders == 0 && numOfWriters == 0) {
				list.remove(0);
				numOfWriters++;
				signal(ok);
			} else {
				break;
			}
		}
	}
	
}

- Tehnika Passing the Condition
	* ova tehnika kod monitora je slicna tehnici prosledjivanja stafetne palice kod semafora
	* kod ove tehnike proces koji je zakljucio da treba da probudi neki drugi proces odradi posao za njega i onda ga probudi
	* ova tehnika nam je od interesa kod monitora koji imaju disciplinu Signal and Continue jer se tu probudjeni proces prebacuje iz reda 
	blokiranih procesa na uslovnoj promenljivoj u entry queue nakon budjenja i zato nemamo pojma kada ce on uci zaista u monitor
	
* korisnika (programera sekvencijalnog koda) ne zanima kako je monitor implementiran, njemu je samo potrebno uputstvo kako se monitor 
koristi da bi mogao da primeni sinhronizaciju na svoj kod - on ce samo pozivati metode monitora bez poznavanja njegove implementacije

- Shortest Next Allocation Monitor
	* prednost pri budjenju imaju procesi koji su najavili da ce koristiti resurs najkrace vreme
	* ovo je zapravo binarni semafor realizovan preko monitora
		- to je zato sto u ovom problemu imamo jedan resurs koji se dodeljuje procesima i na njega se upravo odnosi promenljiva
		free koja onda ocigledno predstavlja semaforsku promenljivu jednog binarnog semafora
		- binarni semafor je onaj cija semaforska promenljiva nije ceo broj, vec boolean vrednost
	* metodom request se trazi ekskluzivno pravo pristupa deljenom resursu
		- resurs procesi koriste negde izvan monitora, u delu koda koji ne sluzi za sinhronizaciju
			* procesi nikako ne treba da obradjuju resurs unutar monitorskih metoda jer bi to pomesalo sinhronizacioni i sekvencijalni kod
			i jos dodatno bi blokiralo potencijalno monitor na neograniceno dugo vreme i samim tim i ceo nas program
		- uvek treba teziti eksplicitnom razdvajanju koda za sinhronizaciju (njega enkapsuliramo u monitor) i obicnog sekvencijalnog koda (njega
		pisemo van monitorskih metoda)
	* metodom release se proces odrice ekskluzivnog prava pristupa resursu 
	* metode request i release lice na metode wait i signal kod semafora, medjutim ovde se dodatno metodi request prosledjuje kao parametar
	najava procesa koliko vremena zeli da koristi dati resurs
	* ovo resenje je primenjivo u programskim jezicima u kojima uslovna promenljiva ima prioritetni red u kojem sortira neopadajuce procese
	prema najavljenom vremenu koriscenja resursa
		- u Javi npr. ovo nije moguce jer bi tu turn.wait(time) imalo efekat da se proces blokira na time milisekundi sto je potpuno druga stvar
		u odnosu na zeljeni efekat u ovom problemu
		
	* u slucaju da nemamo obezbedjen prioritetni red cekanja na uslovnoj promenljivoj turn, ovaj problem bismo mogli da resimo kod monitora
	koji imaju disciplinu Signal and Continue koristeci notifyAll, tj. kada proces koji napusta monitor treba da pusti neki drugi proces u monitor,
	on budi sve procese koji su blokirani na uslovnoj promenljivoj, ali ce se pustiti samo onaj koji je najavio najkrace vreme koriscenja resursa
		- ovo je veoma neefikasno jer se uvek bude svi blokirani procesi na uslovnoj promenljivoj (to su veliki rezijski troskovi), a pusta se samo jedan
		- ovo podseca na Ticket algoritam
		
		- ovo se takodje moze resiti i Andersenovim algoritmom (pod uslovom da znamo koliko tacno ukupno procesa ima, jer onda znamo kolika
		duzina niza nam treba, tj. koliko uslovnih promenljivih tako da svaki proces ima svoju)
			* koriscenjem niza gde se svaki element odnosi na po jednu uslovnu promenljivu (svaki proces ceka na svojoj uslovnoj promenljivoj) - na
			taj nacin se smanjuju rezijski troskovi tako sto se ne bude uvek svi procesi, vec se budi samo onaj koji treba (zajedno sa drugim procesima
			koji osluskuju istu kes liniju u nizu, ali opet je u zbiru to dosta manje probudjenih procesa nego da se svi bude)
		- ukoliko ne znamo tacan broj procesa, Andersenov algoritam moze i da se aproksimira tako sto bismo alocirali niz odredjene duzine, pri
		cemu bismo poslednji element niza koristili kao uslovnu promenljivu za sve procese nakon sto su ostali elementi niza svi iskorisceni - u tom
		slucaju bismo onda imali vise procesa koji cekaju na istoj uslovnoj promenljivoj, pa bismo tu opet imali notifyAll, ali bi bili smanjeni rezijski
		troskovi svakako zahvaljujuci ostatku niza u kom je svaka uslovna promenljiva dodeljena tacno jednom procesu
		
		- ovo se takodje moze resiti i CLH algoritmom, tako da svaki proces opet ima svoju uslovnu promenljivu, pri cemu ne moramo da unapred
		znamo broj procesa jer se uslovne promenljive dinamicki prave
			* potencijalni problem je to sto ne podrzavaju svi programski jezici dinamicko pravljenje uslovnih promenljivih (Java podrzava), vec
			bi kod njih lista morala staticki da se unapred alocira
				- u takvim jezicima bismo morali da aproksimiramo CLH algoritam na slican nacin kao sto smo aproksimirali Andersenov algoritam, tako
				da poslednji element liste predstavlja uslovnu promenljivu na kojoj cekaju svi procesi koji nisu dobili svoju uslovnu promenljivu od ostatka
				liste
		
		
monitor Shortest_Job_next {
	boolean free = true;
	cond turn;
	
	void request(int time) {
		if (free) {
			free = false;
		} else {
			turn.wait(time);
		}
	}
	
	void release() {
		if (turn.empty()) {
			free = true;
		} else {
			turn.signal();
		}
	}
}

- Interval Timer Monitor
	* u ovom problemu zelimo da realizujemo metodu sleep(interval) koja blokira proces na interval jedinica vremena
	* vreme budjenja procesa se racuna kao wake_time = tod + interval, gde je tod trenutno vreme, a interval broj jedinica vremena
	koliko proces treba da se uspava
	* svaki proces onda ostaje zablokiran sve dok tod (tekuce vreme) ne postane vece od wake_time izracunatog za dati proces
	* ovaj monitor ima dve metode:
		- delay(interval); // ovo je isto kao metoda sleep(interval) koju smo do sada uvek koristili na fakultetu
		- tick();  // ova metoda se poziva kada istekne jedan kvant vremena i tada se azurira promenljiva tod koja pokazuje tekuce vreme
		
	* Prekrivanje uslova - Covering condition
		- logika ove tehnike je da se bude svi procesi i onda svaki proces proverava da li treba opet da se zablokira ili moze da nastavi izvrsavanje
		- kod ove tehnike je pretpostavka da imamo samo jednu uslovnu promenljivu na kojoj se svi procesi blokiraju
		- mana ove tehnike je u tome sto se bude svi procesi, a samo jedan ce moci da nastavi da se izvrsava - veliki rezijski troskovi
		- u prve 4 verzije Jave je postojala samo jedna uslovna promenljiva, ali je od pete verzije Jave uvedeno postojanje biblioteckih uslovnih 
		promenljivih kojih moze da bude vise i time je olaksano konkurentno programiranje u Javi
		- ova tehnika nije pozeljna za koriscenje zbog velikih rezijskih troskova
		- ovo resenje moze da se unapredi tako sto svaki proces kada izracuna svoj wake_time njega umetne u listu koju odrzavamo neopadajuce, pa
		bismo pozivali signal_all samo u slucaju kada je tod postao veci od prvog elementa te liste jer to znaci da postoji bar jedan proces koji zaista
		treba da se budi - na ovaj nacin su malo ublazena nepotrebna budjenja tako sto sada makar budimo sve procese samo onda kada bar jedan
		proces zaista i treba da se probudi
		
		monitor Timer {
			int tod = 0;
			cond check;
			
			void delay(int interval) {
				int wake_time;
				wake_time = tod + interval;
				while (wake_time > tod) {
					check.wait();
				}
			}
			
			void tick() {
				tod++;
				check.signal_all();
			}
		}
	
	* Priority Wait Timer
		- dosta smanjen broj procesa koji se budi jer se budi uvek onaj proces koji je sledeci na redu posto je red cekanja na uslovnoj promenljivoj
		check realizovan kao prioritetni
		- moze se dogoditi da vise razlicitih procesa imaju isti wake_time jer se wake_time racuna kao tod + interval, pa je moguce ako su se dva
		procesa zablokirala u razlicitim trenucima i imaju razlicite vrednosti interval da se dogodi da su im zbirovi tod + interval isti
			* u metodi tick procesi se bude u petlji - upravo zato sto moze da ih bude vise koji treba da se probude u istom trenutku
	
		monitor Timer {
			int tod = 0;
			cond check;
			
			void delay(int interval) {
				int wake_time;
				wake_time = tod + interval;
				if (wake_time > tod) {
					check.wait(wake_time);
				}
			}
			
			void tick() {
				tod++;
				while (!check.empty() && check.minrank() <= tod) {
					check.signal();
				}
			}
		}
		
- Sleeping Barber Rendezvous
	* opis problema: 
		- Imamo berberina i musterije (oni svi predstavljaju procese). Musterije dolaze do berbernice, proveravaju da li ima mesta u berbernici, i 
		ako ima one sedaju i cekaju svoj red da budu opsluzene. Ako nema mesta, musterija ne ulazi u berbernicu, vec odlazi i onda mozda kasnije 
		ponovo svrati ili ode u neku drugu berbernicu. Berberin sisa musteriju ukoliko ima musterije koja ceka, a ako nema onda on ceka dok neka 
		musterija ne dodje. Berberin nakon sisanja musterije treba da joj naplati i da je isprati do izlaza. Ovaj problem je zapravo apstrakcija 
		klijent-server arhitekture. To je slucaj zato sto imamo veci broj klijenata (musterije) koji mogu da upute svoj zahtev serveru (berberinu).
		Berberin uzima zahteve jedan po jedan, odradjuje ih redom i obavestava musterije da je posao gotov. Tek kada trenutno opsluzivana
		musterija napusti berbernicu, berberin moze da pocne da sisa narednu musteriju.
	* delovi sa sinhronizacijom:
		- musterija treba da obavesti berberina da je dosla
		- musterija placa berberinu (potencijalno)
		- berberin treba da obavesti musteriju da je posao zavrsen (tek tada musterija moze da napusti berbernicu)
	* imacemo veci broj redova cekanja:
		- jedan red cekanja za musterije koje su dosle u berbernicu i cekaju svoj red za sisanje
		- jedan red cekanja za musteriju koja je na redu
		- jedan red cekanja za berberina (na kom on ceka dok nema nikoga ko zeli da se sisa)
		
- Client/Server arhitektura
	* berbernica ce biti predstavljena pomocu monitora
	* imacemo dva tipa procesa:
		- proces server (berberin)
		- proces klijent (musterija)
	* imacemo 3 metode:
		- get_haircut
			* ovu metodu poziva musterija kada zahteva sisanje
		- get_next_customer
			* ovu metodu poziva berberin kada je spreman da primi sledecu musteriju
		- finished_cut
			* ovu metodu poziva berberin kada zavrsi sisanje musterije
	* sam proces sisanja se obavlja van monitora
		- to je standardno pravilo, duge radnje se nikada ne obavljaju u monitorskim metodama
	* za sinhronizaciju izmedju berberina i musterije koja je dosla na red cemo koristiti tehniku koja se zove rendezvous
		- to je ustvari sinhronizacija na barijeri za dva procesa (berberin i bilo koja musterija koja je dosla na red)
		
- Sinhronizaciona stanja
	* berberin
		- postaje raspoloziv, sisa, i poziva napustanje
	* musterije
		- sede u stolici i napustaju
	* berberin se budi kada postoji bar jedna musterija koja ceka
	* musterija se zablokira ako vec ima neko ko se sisa ili neko ko ceka na sisanje
	* ova stanja bismo mogli da pratimo koriscenjem brojaca:
		- cinchair (broj musterija koje su sele u stolicu)
		- cleave (broj musterija koje su napustile berbernicu)
		
		- bavail (koliko puta je berberin bio raspoloziv)
		- bbusy (koliko puta je berberin sisao)
		- bdone (koliko puta je berberin ispratio musteriju do izlaza)
	* medjutim, to bi bilo isuvise komplikovano resenje i imali bismo beskonacno inkrementiranje brojaca
	* umesto toga, koristicemo tri promenljive koje mogu da imaju vrednosti 0 ili 1
		- barber (ovo je kao bavail - cinchair)
			* ova promenljiva govori da li je berberin slobodan (barber = 1) ili nije (barber = 0)
		- chair (ovo je kao cinchair - bbusy)
			* ova promenljiva govori da li je stolica slobodna (chair = 1) ili nije (chair = 0)
		- open (ovo je kao bdone - cleave)
			* ova promenljiva govori da li su vrata otvorena (open = 1) ili nisu (open = 0)
	* pomocu ovih promenljivih cemo obezbediti ping-pong komunikaciju - neko ih postavi, pa ih neko drugi resetuje
		- takvu komunikaciju smo vec imali kod sinhronizacije na barijeri sa ili bez procesa koordinatora (neko kaze da treba nesto da se odradi,
		a neko drugi javi da je to uradio)
	* pretpostavka je da je berbernica u ovom slucaju neogranicenog kapaciteta i da svaka musterija koja dodje na sisanje ceka ako treba i 
	beskonacno dugo dok ne dodje na red za sisanje
		- kada bi berbernica bila konacnog kapaciteta, samo bismo uveli brojac koji broji koliko musterija je trenutno u berbernici
	* sinhronizacioni uslovi:
		- za berberina:
			1) da musterija seda na stolicu 
			2) da musterija odlazi iz berbernice
		- za musteriju:
			1) da je berberin raspoloziv 
			2) da berberin isprati musteriju do izlaza i otvori joj vrata
	* samo sisanje berberina se obavlja izvan naseg monitora i to nas ni ne zanima kako se dogadja, mi se ovde bavimo samo sinhronizacijom
	* rendezvous (ping-pong komunikacija) se uvek implementira ovako:
		- prijemna strana ceka uslov i resetuje promenljivu
		- strana koja obavestava signalizira uslov i postavlja promenljivu
	* rendezvous se cesto koristi kada imamo dva procesa koje treba sinhronizovati (ovde su to berberin i musterija)
		
* ovaj problem se moze dodatno zakomplikovati ako je potrebno sinhronizovati i musterije medjusobno, da bismo ispostovali redosled dolaska
musterija
	- pretpostavka u ovom slucaju je da je berbernica ogranicenog kapaciteta N
	- moglo bi ovo da se resi pomocu Priority Wait Timer monitora gde se svakom procesu (musteriji) dodeljuje prioritet i prema tome se oni bude
	- takodje bi moglo da se resi pomocu Andersenovog algoritma ukoliko nam nisu dostupne uslovne promenljive sa prioritetnim redovima cekanja
		* tu bismo koristili niz od N uslovnih promenljivih gde svaka musterija ceka na svojoj i uvek se budi naredna musterija koja je na redu -
		dakle obezbedjen je FIFO
			- tu je logika svako jedini ceka na svojoj uslovnoj promenljivoj i onda nam je nebitno kako je ona implementirana jer svakako sigurno
			znamo redosled posto moze samo taj jedini proces da se probudi jer jedini uvek i ceka

monitor Barber_Shop {
	int barber = 0, chair = 0, open = 0;
	cond barber_available;  // signal kada je barber > 0
	cond chair_occupied;  // signal kada je chair > 0
	cond door_open;  // signal kada je open > 0
	cond customer_left;  // signal kada je open = 0
	
	// ovu metodu poziva musterija kada udje u berbernicu i zeli da se sisa
	void get_haircut() {
		// musterija ceka da berberin postane slobodan (to ce berberin javiti tako sto ce postaviti promenljivu barber na 1)
		while (barber == 0) {
			barber_available.wait();
		}
		// berberin postaje zauzet zbog ove musterije koja je zatrazila sisanje
		barber--;
		// musterija ovako obavestava berberina da je sela u stolicu
		chair++;
		chair_occupied.signal();
		// musterija ceka da je berberin isprati do izlaza i otvori joj vrata (znaci berberin tako obavestava musteriju da je sisanje gotovo)
		while (open == 0) {
			door_open.wait();
		}
		// postavljanjem promenljive open na 0 musterija javlja da je zatvorila vrata
		open--;
		// ovako musterija obavestava berberina da je otisla
		customer_left.signal();
	}
	
	// ovu metodu poziva berberin kada je spreman da zapocne novo sisanje
	void get_next_customer() {
		// berberin javlja musteriji da je slobodan
		barber++;
		barber_available.signal();
		// berberin ceka da musterija sedne na stolicu
		while (chair == 0) {
			chair_occupied.wait();
		}
		// musterija je sela na stolicu pa berberin resetuje promenljivu chair jer je stolica sad zauzeta	
		chair--;
	}
	
	// ovu metodu poziva berberin nakon sto je zavrsio sisanje
	void finished_cut() {
		// berberin javlja musteriji da je gotovo sisanje
		open++;
		door_open.signal();
		// berberin ceka da musterija javi da je izasla iz berbernice
		while (open > 0) {
			customer_left.wait();
		}
	}
}

- Problem kruznog toka
	* Raskrsnica kruznog toka ima 3 dvosmerne ulice sa po jednom saobracajnom trakom u svakom smeru povezane na kruzni tok. Prednost u
	kruznom toku imaju vozila koja se vec nalaze u kruznom toku. Treba realizovati monitor u kome ce se regulisati saobracaj kruznog toka.
	Smatra se da, ako u prethodnom segmentu kruznog toka ima vozila, mora da se ceka na ulazu u kruzni tok. Takodje, vozila moraju da cekaju
	vozila ispred sebe na ulaznoj ulici u kruzni tok (u jednoj saobracajnoj traci). Kruzni tok ima 3 segmenta (po jedan izmedju svake dve ulice
	koje su povezane na kruzni tok).
	* nemamo pojma koliko dugo ce se vozila zadrzati u kruznom toku, tako da kretanje vozila nikako ne smemo stavljati u nas monitor jer je tod
	radnja koja traje neodredjeno dugo
	* nas monitor samo treba da obezbedi sinhronizaciju izmedju vozila koja ulaze u kruzni tok, izlaze iz kruznog toka i vozila koja prelaze iz
	jednog segmenta kruznog toka u drugi
	
	* da bi vozilo uslo u kruzni tok, mora da ne bude niko ispred njega u ulici koja je povezana na kruzni tok i da nema vozila u segmentu kruznog
	toka koji je levo od te ulice
	* vozilo uvek moze da izadje iz kruznog toka, tu nemamo ogranicenje
	* vozilo uvek moze da predje u naredni segment kruznog toka, ni tu nemamo ogranicenje (jer vozila u kruznom toku imaju prednost)
	
	* izgladnjivanje vozila koja ulaze u kruzni tok nastaje samo u slucaju ako vozila sto su u kruznom toku nikada ne izlaze iz njega
		- smatramo da to nije slucaj
		
	* koristicemo monitor sa disciplinom Signal and Wait u kom su obezbedjene uslovne promenljive sa FIFO redosledom
		- tako je obezbedjen FIFO na ulazu u kruzni tok
	* resenje sa monitorom sa disciplinom Signal and Continue je kompleksnije, pa zato biramo Signal and Wait (ako mozemo da biramo)
		
monitor Kruzni_Tok {
	const int N = 3;  // broj segmenata kruznog toka, a u isto vreme i broj ulaza u kruzni tok
	int count[N] = {0};  // brojac vozila u svakom segmentu kruznog toka
	condition enter[N];  // uslovne promenljive za ulaz u kruzni tok (za svaki ulaz po jedna)
	
	// ulaz u kruzni tok
	void start(int segment) {
		// ako ima vozila ispred koji cekaju u ulici koja je povezana na kruzni tok ili ako ima vozila u segmentu kruznog toka levo od naseg ulaza,
		// nase vozilo se blokira i ceka u ulici povezanoj na kruzni tok
		if (enter[segment].queue() || count[segment] != 0) {
			enter[segment].wait();
		}
		// nase vozilo ulazi u kruzni tok i ide u segment kruznog toka desno od nase ulice koja je povezana na kruzni tok
		count[segment % N + 1]++; 
	}
	
	// izlaz iz kruznog toka
	void leave(int segment) {
		// vozilo uvek moze da izadje iz kruznog toka
		count[segment]--;
		// dokle god ima vozila koji cekaju da udju u kruzni tok desno od segmenta iz kog je vozilo upravo izaslo iz kruznog toka i dokle god
		// je taj segment kruznog toka prazan (bez ijednog vozila), dopustamo ulazak novih vozila u kruzni tok i oni ce ulaziti ne u ovaj 
		// prazan segment, vec u segment desno od tog;
		
		// bitno da se u petlji proverava stalno i uslov count[segment] == 0 jer kada se pozove signal, proces napusta monitor i odmah ga prepusta
		// probudjenom procesu i ne znamo kada ce se opet vratiti u monitor, tako da je moguce da se u medjuvremenu i promeni vrednost
		// count[segment]
		while (enter[segment].queue() && count[segment] == 0) {
			enter[segment].signal();
		}
	}
	
	void moveFrom(int segment) {
		// prelazak u naredni segment
		count[segment % N + 1]++;
		// napustanje tekuceg segmenta - pozivamo funkciju iznad gde smo to vec implementirali
		leave(segment);
	}
}